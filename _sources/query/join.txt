*************************
浅谈SQL常用的JOIN算法
*************************




:author: sunshangchun
:date: 2013-08-22


常用的三种类型的连接

嵌套循环连接(Nested Loops)
==============================



基于Tuple的嵌套循环连接
------------------------

R(X,Y) :math:`\bowtie` S(Y, Z)

伪代码如下::
  
  For R的每个Tuple r:
    For S的每个Tuple s:
      If r 与 s连接形成 Tuple t:
        输出t

如果不做任何缓冲优化,这种算法需要的磁盘I/O多达T(R)*T(S).
不过，在很多情况下这种算法可以优化，使代价降低许多.

优化一 基于Block的嵌套循环连接
-----------------------------

思路: 使用内存缓存，减少磁盘读写。
显然在基于Tuple的遍历中，内存循环每个Tuple的读取次数是T(R)次，外层循环的每个Tuple只需要一次。
因此缓存S的数据是很自然的。

我们假定一个Block包含N个Tuple, R有T(R)/N=B(R)块,S为T(S)/N=B(S)块; 
假定内存可以容纳M个Block。并假定大小 M < B(S) <= B(R) 

我们加载M-1块个S到内存中，剩余1个Block用于加载R的数据，这样在内层遍历时只需要访问内存，
无须再访问磁盘了。伪代码如下 ::
  
  While (true):
    trunk=读取S的M-1个块到内存;
    If 读取完成:
      break;
    对trunk建立查询结构I，比如使用hash索引或者红黑树等;
    For R的每个block b:
      读取b到内存
      For b的每个Tuple t:
        通过I,找出所有能够与t连接的Tuple并输出;
      

显然,磁盘的读取次数为 B(S)/(M-1) * (B(R) + M) = (B(S)*B(R)+B(S)*M))/(M-1)
从中也可以看到, 外层是小连接会更好一些.

优化二 基于索引的方式
-------------------------

合并
==================

由于每个输入都已排序，因此 Merge Join 运算符将从每个输入获取一行并将其进行比较。
例如，对于内联接操作，如果行相等则返回。如果行不相等，则废弃值较小的行并从该输入获得另一行。
这一过程将重复进行，直到处理完所有的行为止。
合并联接本身的速度很快，但如果需要排序操作，选择合并联接就会非常费时。
然而，如果数据量很大且能够从现有 B 树索引中获得预排序的所需数据，则合并联接通常是最快的可用联接算法。

显然，如果两个表在on的过滤条件上都有有序索引, 使用Merge join, 性能最好. M+N次;

::
  a = BigTable.begin();
  b = SmallTable.begin();
  while (true) {
    if (a is null or b is null) break;
    if (a.key == b.key): emit(a, b);
    else if (a.key > b.key): b.next();
    else: a.next();
  }

      
哈希
===================

如果一个有索引,一个没索引,则会选择Nested Loops join.
 

3.哈希联接(Hash)
如果两个表在on的过滤条件上都没有索引, 则就会使用Hash join.

也就是说, 使用Hash join算法是由于缺少现成的索引.
FOR S


参考资料:

[1] `高级查询优化概念 <http://msdn.microsoft.com/zh-cn/library/ms191426(v=SQL.100).aspx>`_

[2] 
